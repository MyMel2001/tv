<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sparkSammy TV</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.10"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            min-height: 100vh;
        }
        .container {
            display: flex;
            max-width: 1920px;
            margin: 20px auto;
            gap: 20px;
            padding: 0 20px;
            height: calc(100vh - 40px);
        }
        #channel-sidebar {
            flex: 1;
            max-width: 30%;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        h1 {
            text-align: center;
            margin-bottom: 24px;
            font-size: 2.2em;
            background: linear-gradient(90deg, #00d4ff, #ff00c8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .channel-item {
            display: flex;
            align-items: center;
            padding: 14px 16px;
            margin: 8px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .channel-item:hover { background: rgba(255,255,255,0.2); transform: translateY(-2px); }
        .channel-item.active {
            background: linear-gradient(90deg, #00d4ff, #ff00c8);
            color: #000;
            font-weight: bold;
        }
        .channel-logo {
            width: 48px; height: 48px;
            border-radius: 8px;
            margin-right: 14px;
            object-fit: contain;
            background: #000;
            padding: 4px;
        }
        .channel-name { flex: 1; font-size: 1.05em; }

        #player-sidebar {
            width: 74%;
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #video-player {
            width: 100%;
            height: 100%;
            background: #000;
        }
        #now-playing {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            padding: 18px;
            background: linear-gradient(transparent, rgba(0,0,0,0.9));
            font-size: 1.3em;
            text-align: center;
            font-weight: bold;
        }
        .loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3;
            border-top: 8px solid #00d4ff;
            border-radius: 50%;
            width: 70px; height: 70px;
            animation: spin 1s linear infinite;
            z-index: 10;
        }
        @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }

        @media (max-width: 1200px) {
            .container { flex-direction: column; }
            #channel-sidebar, #player-sidebar { max-width: 100%; width: 100%; }
            #player-sidebar { position: relative; height: 65vh; }
        }
    </style>
</head>
<body>

<div class="container">
    <div id="channel-sidebar">
        <h1>sparkSammy TV</h1>
        <div id="channel-list">Loading channels...</div>
    </div>

    <div id="player-sidebar">
        <video id="video-player" controls autoplay playsinline></video>
        <div id="loader" class="loader"></div>
        <div id="now-playing">Select a channel</div>
    </div>
</div>

<script>
    const PROXY = '/yacs/index.php';
    const originalPlaylist = 'https://raw.githubusercontent.com/mymel2001-holder/iptv-action/refs/heads/main/list.m3u';
    const playlistUrl = PROXY + '?url=' + encodeURIComponent(originalPlaylist);

    const video = document.getElementById('video-player');
    const loader = document.getElementById('loader');
    const nowPlaying = document.getElementById('now-playing');
    const channelList = document.getElementById('channel-list');

    let currentHls = null;
    let channels = [];

    // Custom function to load the source using fetch with explicit cache bypass
    function loadHlsSource(hlsInstance, proxyUrl, originalUrl) {
        // Use fetch with cache: 'no-cache' to force the browser to re-validate the resource
        fetch(proxyUrl, {
            method: 'GET',
            cache: 'no-cache', // CRITICAL: Bypasses browser's local cache
            headers: {
                'X-Request-Bypass': Date.now().toString() // Extra parameter to help proxy/CDN cache busting
            }
        })
        .then(response => {
            if (!response.ok) throw new Error(`Network response was not ok: ${response.status}`);
            return response.text();
        })
        .then(manifestText => {
            // Load the fetched manifest text directly into HLS.js
            hlsInstance.loadSource(manifestText);
        })
        .catch(error => {
            console.error("Failed to fetch manifest with cache bypass:", error);
            loader.style.display = 'none';
            // Trigger a network error recovery if the fetch fails
            hlsInstance.trigger(Hls.Events.ERROR, {
                type: Hls.ErrorTypes.NETWORK_ERROR,
                details: 'manifestLoadingError',
                fatal: true,
                error: error
            });
        });
    }

    // FINAL PLAY FUNCTION â€” continuous playback + Universal Cache-Busting Handling
    function playChannel(channelUrl, channelName) {
        loader.style.display = 'block';
        nowPlaying.textContent = channelName || 'Loading...';

        // 1. Destroy any existing Hls instance
        if (currentHls) { 
            currentHls.destroy(); 
            currentHls = null; 
        }
        // Ensure video is cleared and paused before starting a new one
        video.src = '';
        video.pause();
        video.onstalled = null; 

        let url = channelUrl;
        
        // ðŸ”‘ CRITICAL FIX: UNIVERSAL CACHE BUSTER STRIPPING (Step 1)
        // This removes the cache-buster if present from a restart attempt.
        url = url.replace(/(\?|&)?cachebuster=\d+/, '');

        // Corrected Pluto URL Replacement Logic (now uses the cleaned 'url')
        if (url.includes('pluto.tv') && url.includes('master.m3u8')) {
            url = url.replace('master.m3u8', '640x360/playlist.m3u8');
        }

        const playUrl = PROXY + '?url=' + encodeURIComponent(url);

        if (Hls.isSupported()) {
            currentHls = new Hls({
                // Optimized Configuration
                startLevel: -1, 
                capLevelToPlayerSize: true,
                maxBufferLength: 15, 
                maxMaxBufferLength: 60,
                
                // RESTORED: Specific Bandwidth Estimate for Pluto TV (300k bps)
                abrEwmaDefaultEstimate: 300000, 
                
                // AGGRESSIVE LIVE STREAM SETTINGS:
                liveSyncDurationCount: 5,   
                liveMaxLatencyDurationCount: 15, 
                liveDurationInfinity: true,

                // CRITICAL STALL AVOIDANCE SETTINGS
                maxBufferHysteresis: 10, 
                lowBufferWatchdogPeriod: 2, 
                manifestLoadingMaxRetryTimeout: 15000, 
                fragLoadingMaxRetryTimeout: 15000,
            });

            // CRITICAL: Attach media immediately
            currentHls.attachMedia(video);
            
            // ðŸ”‘ CRITICAL FIX: Load source using the cache-busting fetch function
            loadHlsSource(currentHls, playUrl, channelUrl);

            currentHls.on(Hls.Events.MANIFEST_PARSED, () => {
                loader.style.display = 'none';
                video.play().catch(e => console.warn("Auto-play failed (user interaction needed):", e));
            });
            
            // --- Buffer Reset Handler ---
            currentHls.on(Hls.Events.BUFFER_RESET, () => {
                console.log("HLS Buffer system reset. Attempting restart.");
                loader.style.display = 'none';
                video.play().catch(e => {});
            });

            // HLS Error Handling for Recovery
            currentHls.on(Hls.Events.ERROR, (event, data) => {
                console.warn('HLS.js Error:', data);
                loader.style.display = 'none';

                if (data.fatal) {
                    if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                        console.log("Media Error, recovering...");
                        currentHls.recoverMediaError();
                    } else if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                        console.log("Fatal Network Error, restarting channel...");
                        currentHls.destroy();
                        setTimeout(() => playChannel(channelUrl, channelName), 5000); 
                    } else {
                        console.log("Other Fatal Error, restarting channel...");
                        currentHls.destroy();
                        setTimeout(() => playChannel(channelUrl, channelName), 3000);
                    }
                } 
                // !!! AGGRESSIVE FIX: Treat non-fatal buffer stalls as fatal and restart
                else if (data.details === 'levelEmptyError' || data.details === 'bufferStalledError') {
                    console.log(`NON-FATAL STALL (${data.details}). Forcing full channel restart in 1 second with CACHE BUSTER.`);
                    currentHls.destroy();
                    
                    // ðŸ”‘ CRITICAL FIX: CACHE BUSTING on RESTART (Step 2)
                    // Append a unique parameter (timestamp) to the original channelUrl for the RESTART call
                    const cacheBustedUrl = channelUrl + (channelUrl.includes('?') ? '&' : '?') + 'cachebuster=' + Date.now();
                    
                    setTimeout(() => playChannel(cacheBustedUrl, channelName), 1000); 
                }
            });
            
            // Optional: for logging when buffering completes
            currentHls.on(Hls.Events.FRAG_BUFFERED, (event, data) => {
                if (video.paused && video.readyState >= 3) { 
                    video.play().catch(e => console.log('Auto-play failed after buffer:', e));
                }
            });

        } else {
            // Fallback for non-HLS browsers
            video.src = playUrl;
            video.play().catch(e => console.warn("Play failed on fallback:", e));
        }
    }

    // M3U PARSER
    function parseM3U(text) {
        const lines = text.split('\n');
        let ch = {};
        channels = []; // reset

        for (let line of lines) {
            line = line.trim();
            if (line.startsWith('#EXTINF:')) {
                const name = line.match(/,(.+)$/)?.[1]?.trim() || 'Unknown';
                const logo = line.match(/tvg-logo="([^"]+)"/i)?.[1] || '';
                ch = { name, logo };
            } else if (line && !line.startsWith('#') && ch.name) {
                ch.url = line;
                channels.push({ ...ch });
                ch = {};
            }
        }
        renderChannels();
    }

    function renderChannels() {
        channelList.innerHTML = '';
        channels.forEach((ch, i) => {
            const div = document.createElement('div');
            div.className = 'channel-item';
            div.innerHTML = `
                ${ch.logo ? `<img src="${ch.logo}" class="channel-logo" onerror="this.style.display='none'">` : ''}
                <div class="channel-name">${ch.name}</div>
            `;
            div.onclick = () => {
                document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
                div.classList.add('active');
                playChannel(ch.url, ch.name);
            };
            channelList.appendChild(div);
        });
    }

    // Load the main playlist
    fetch(playlistUrl)
        .then(r => r.ok ? r.text() : Promise.reject('Playlist failed'))
        .then(text => parseM3U(text))
        .catch(err => {
            channelList.innerHTML = `<p style="color:#ff6b6b;text-align:center;padding:30px">
                Failed to load channels<br><small>${err}</small>
            </p>`;
        });
</script>
</body>
</html>
