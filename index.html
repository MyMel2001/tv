<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sparkSammy TV</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.10"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            min-height: 100vh;
        }
        .container {
            display: flex;
            max-width: 1920px;
            margin: 20px auto;
            gap: 20px;
            padding: 0 20px;
            height: calc(100vh - 40px);
        }
        #channel-sidebar {
            flex: 1;
            max-width: 30%;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        h1 {
            text-align: center;
            margin-bottom: 24px;
            font-size: 2.2em;
            background: linear-gradient(90deg, #00d4ff, #ff00c8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .channel-item {
            display: flex;
            align-items: center;
            padding: 14px 16px;
            margin: 8px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .channel-item:hover { background: rgba(255,255,255,0.2); transform: translateY(-2px); }
        .channel-item.active {
            background: linear-gradient(90deg, #00d4ff, #ff00c8);
            color: #000;
            font-weight: bold;
        }
        .channel-logo {
            width: 48px; height: 48px;
            border-radius: 8px;
            margin-right: 14px;
            object-fit: contain;
            background: #000;
            padding: 4px;
        }
        .channel-name { flex: 1; font-size: 1.05em; }

        #player-sidebar {
            width: 74%;
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #video-player {
            width: 100%;
            height: 100%;
            background: #000;
        }
        #now-playing {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            padding: 18px;
            background: linear-gradient(transparent, rgba(0,0,0,0.9));
            font-size: 1.3em;
            text-align: center;
            font-weight: bold;
        }
        .loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3;
            border-top: 8px solid #00d4ff;
            border-radius: 50%;
            width: 70px; height: 70px;
            animation: spin 1s linear infinite;
            z-index: 10;
        }
        @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }

        @media (max-width: 1200px) {
            .container { flex-direction: column; }
            #channel-sidebar, #player-sidebar { max-width: 100%; width: 100%; }
            #player-sidebar { position: relative; height: 65vh; }
        }
    </style>
</head>
<body>

<div class="container">
    <div id="channel-sidebar">
        <h1>sparkSammy TV</h1>
        <div id="channel-list">Loading channels...</div>
    </div>

    <div id="player-sidebar">
        <video id="video-player" controls autoplay playsinline></video>
        <div id="loader" class="loader"></div>
        <div id="now-playing">Select a channel</div>
    </div>
</div>

<script>
    const PROXY = '/yacs/index.php';
    const originalPlaylist = 'https://raw.githubusercontent.com/mymel2001-holder/iptv-action/refs/heads/main/list.m3u';
    const playlistUrl = PROXY + '?url=' + encodeURIComponent(originalPlaylist);

    const video = document.getElementById('video-player');
    const loader = document.getElementById('loader');
    const nowPlaying = document.getElementById('now-playing');
    const channelList = document.getElementById('channel-list');

    let currentHls = null;
    let channels = [];

    function playChannel(channelUrl, channelName) {
        loader.style.display = 'block';
        nowPlaying.textContent = channelName || 'Loading...';

        if (currentHls) { 
            currentHls.destroy(); 
            currentHls = null; 
        }
        video.src = '';
        video.pause();
        video.onstalled = null; 

        // 1. Clean URL (remove any old cachebusters)
        let url = channelUrl.replace(/(\?|&)?cachebuster=\d+/, '');
        
        // 2. Initial Proxy Wrap
        // We wrap the initial manifest load here.
        // Subsequent internal requests (keys, segments) are handled by xhrSetup below.
        let playUrl = url;
        if (!playUrl.includes(PROXY)) {
             playUrl = PROXY + '?url=' + encodeURIComponent(url);
        }

        if (Hls.isSupported()) {
            currentHls = new Hls({
                // --- ðŸ”‘ CRITICAL FIX: INTERCEPT AND PROXY EVERYTHING ---
                // This function runs before *every* network request (Manifest, Key, Segment).
                // If HLS.js tries to fetch a raw URL (like the key file), we rewrite it to use the proxy.
                xhrSetup: function(xhr, url) {
                    // 1. Check if the URL is going to our proxy
                    if (url.indexOf(PROXY) === -1) {
                        // It's a raw URL (e.g. key file or redirect). Proxy it!
                        // We have to modify the 'open' method of the XHR because the URL is already set by the time we get here.
                        
                        // NOTE: HLS.js passes the url string to xhrSetup, but modifying the string arg doesn't change the XHR.
                        // We must re-open the XHR with the new URL.
                        let proxiedUrl = PROXY + '?url=' + encodeURIComponent(url);
                        xhr.open('GET', proxiedUrl, true);
                    }

                    // 2. Set Cache-Busting Headers
                    xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
                    xhr.setRequestHeader('Pragma', 'no-cache');
                    xhr.setRequestHeader('Expires', '0');
                },
                
                startLevel: -1, 
                capLevelToPlayerSize: true,
                maxBufferLength: 15, 
                maxMaxBufferLength: 60,
                abrEwmaDefaultEstimate: 300000, 
                liveSyncDurationCount: 3, 
                liveMaxLatencyDurationCount: 10,
                liveDurationInfinity: true,
                // Aggressive timeouts
                manifestLoadingTimeOut: 10000,
                manifestLoadingMaxRetry: 2,
                fragLoadingTimeOut: 10000,
                fragLoadingMaxRetry: 3,
            });

            currentHls.attachMedia(video);
            currentHls.loadSource(playUrl);

            currentHls.on(Hls.Events.MANIFEST_PARSED, () => {
                loader.style.display = 'none';
                video.play().catch(e => console.warn("Auto-play failed:", e));
            });
            
            // --- RECOVERY LOGIC ---
            currentHls.on(Hls.Events.ERROR, (event, data) => {
                // Filter out non-fatal errors
                if (!data.fatal && data.details !== 'bufferStalledError') return;

                console.warn('HLS Error:', data.details);

                if (data.fatal || data.details === 'bufferStalledError') {
                    console.log("Fatal/Stall. Reloading...");
                    currentHls.destroy();
                    setTimeout(() => playChannel(channelUrl, channelName), 1000);
                }
            });
            
            currentHls.on(Hls.Events.FRAG_BUFFERED, (event, data) => {
                if (video.paused && video.readyState >= 3) { 
                    video.play().catch(e => {});
                }
            });

        } else {
            // Fallback for Safari
            video.src = playUrl;
            video.play().catch(e => console.warn("Fallback play failed:", e));
        }
    }

    function parseM3U(text) {
        const lines = text.split('\n');
        let ch = {};
        channels = []; 

        for (let line of lines) {
            line = line.trim();
            if (line.startsWith('#EXTINF:')) {
                const name = line.match(/,(.+)$/)?.[1]?.trim() || 'Unknown';
                const logo = line.match(/tvg-logo="([^"]+)"/i)?.[1] || '';
                ch = { name, logo };
            } else if (line && !line.startsWith('#') && ch.name) {
                ch.url = line;
                if (ch.url && ch.url.startsWith('http')) {
                    channels.push({ ...ch });
                }
                ch = {};
            }
        }
        renderChannels();
    }

    function renderChannels() {
        channelList.innerHTML = '';
        channels.forEach((ch, i) => {
            const div = document.createElement('div');
            div.className = 'channel-item';
            div.innerHTML = `
                ${ch.logo ? `<img src="${ch.logo}" class="channel-logo" onerror="this.style.display='none'">` : ''}
                <div class="channel-name">${ch.name}</div>
            `;
            div.onclick = () => {
                document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
                div.classList.add('active');
                playChannel(ch.url, ch.name);
            };
            channelList.appendChild(div);
        });
    }

    fetch(playlistUrl)
        .then(r => r.ok ? r.text() : Promise.reject('Playlist failed'))
        .then(text => parseM3U(text))
        .catch(err => {
            channelList.innerHTML = `<p style="color:#ff6b6b;text-align:center;padding:30px">
                Failed to load channels<br><small>${err}</small>
            </p>`;
        });
</script>
</body>
</html>
